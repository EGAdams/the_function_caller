My files are as follows: McbaFragment.java:\npackage com.awm.mcba.base.initial_download_operations;\n\nimport android.annotation.SuppressLint;\nimport android.app.ProgressDialog;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport com.awm.mcba.base.progressTools.DownloadTimer;\nimport com.awm.mcba.base.progressTools.McbaProgressDialog;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class McbaFragment extends android.app.Fragment {\n    private static final String TAG = "MCBAFragment";\n    private static final int DOWNLOAD_TIMEOUT = 30000;\n\n    /* Project specific constants */\n    private static String SITEMAP;\n    private static String CONFIGJSON;\n\n    private boolean downloadTemplateJSON = false;\n    private boolean downloadTemplateJSONGotSiteMap = false;\n    public McbaUpdateManager mUpdateManager = null;\n    private McbaWebView mWebView = null;\n    private DownloadTimer downloadTimer = null;\n    private int numberOfdownloadedFiles = 0;\n    private int numberOfFilesToDownload = 0;\n\n    /*\n     * changed to McbaProgressDialog on march 30, 2018 -EG\n     */\n    // private ProgressDialog      mProgressDialog                 = null;\n    private McbaProgressDialog mProgressDialog = null;\n\n    public McbaFragment() { System.out.println( "constructing McbaFragment..." ); }\n\n    @Override\n    public void onActivityCreated( Bundle savedInstanceState ) {\n        super.onActivityCreated( savedInstanceState );\n    }\n\n    @Override\n    public void onCreate( Bundle savedInstanceState ) {\n        super.onCreate( savedInstanceState );\n        this.setRetainInstance( true );\n        setHasOptionsMenu( false );\n    }\n\n    @SuppressLint("LogNotTimber")\n    @Override\n    public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState ) {\n\n        String url;\n        Settings settings = Settings.getInstance(); // changed to Singleton march 23 -EG\n\n        if( settings.getBaseUrl() != null && !settings.getBaseUrl().isEmpty() ) {\n            url = settings.getBaseUrl() + settings.getMcbaDir();\n        } else {\n            url = settings.getPushUrl();\n        }\n        // url = url.replace( "https", "http" );\n\n        SITEMAP = url + getString( R.string.download_dir ) + "sitemap.php";\n        CONFIGJSON = url + "www/app_config.json";\n        // CONFIGJSON = url + getString( R.string.download_dir ) + "app_config.json";\n\n\n\n        mUpdateManager = new McbaUpdateManager( getActivity() );\n        mUpdateManager.setDownloadFinishedListener( downloadListener );\n\n        /*\n         * start download timer\n         */\n        this.downloadTimer = new DownloadTimer( getActivity() );\n        Log.i( TAG, "*** Starting download timer... ***" );\n        this.downloadTimer.start( DOWNLOAD_TIMEOUT ); // milliseconds before "alarm" goes off\n\n        /*\n         * download configuration map...\n         */\n        Log.i( TAG, "*** Downloading config map app_config.json... ***" );\n        try {\n            mUpdateManager.download( CONFIGJSON );\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        /*\n         * download site map...\n         */\n        Log.i( TAG, "*** Downloading site map... ***" );\n        try {\n            mUpdateManager.download( SITEMAP );\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        mWebView = new McbaWebView( getActivity() );\n\n        /*\n         * refresh the web view in the download\n         * listener\n         */\n        // mWebView.refresh();\n\n        return mWebView;\n    }\n\n    @Override\n    public void onAttach( Context context ) {\n        super.onAttach( context );\n    }\n\n    private final McbaUpdateManager.DownloadFinishedListener downloadListener = new McbaUpdateManager.DownloadFinishedListener() {\n\n\n        @SuppressLint({"StaticFieldLeak", "LogNotTimber"})\n        @Override\n        public void onDownloadFinished( DownloadFile file ) {\n\n            if( mUpdateManager.getPendingDownloadCount() <= 0 ) {\n                Log.i( TAG, "---------- My refresh, downloads done... -------------" );\n\n                if( downloadTemplateJSON && downloadTemplateJSONGotSiteMap ) {\n                    downloadTemplateJSON = false;\n                    downloadTemplateJSONGotSiteMap = false;\n                }\n\n                mWebView.refresh();\n\n                /*\n                 * dismiss dialog ??  on all downloads finished ??\n                 */\n                if( mProgressDialog != null && mProgressDialog.isShowing() ) {\n\n                    Log.i( TAG, "*** dismissing progress dialog... ***" );\n                    mProgressDialog.dismiss();\n\n                    Log.i( TAG, "*** cancelling download timer... ***" );\n                    downloadTimer.cancel();\n                    Intent intent = new Intent();\n                    intent.setAction( "com.awm.mcba.base.CUSTOM_INTENT" );\n                    getActivity().sendBroadcast( intent );\n\n                }\n            } else {  // added else on march 30, 2018 -EG\n\n                numberOfdownloadedFiles++;\n\n                if( mProgressDialog == null ) {\n                    mProgressDialog = new McbaProgressDialog( getActivity() );\n                    mProgressDialog.setMessage( getString( R.string.downloading ) );\n\n                    // mProgressDialog.setIndeterminate(true);\n\n                    mProgressDialog.setProgressStyle( ProgressDialog.STYLE_HORIZONTAL );\n                    mProgressDialog.setMax( 100 );\n                    mProgressDialog.show();\n                } else if( !mProgressDialog.isShowing() ) {\n\n                    Log.i( TAG, "showing progress bar again..." );\n                    mProgressDialog.show();\n\n                    Log.i( TAG, "making a new timer..." );\n\n                    /*\n                     * make new timer.  progress bar is not showing\n                     * so we must assume that a new set of downloads\n                     * is starting.\n                     */\n                    downloadTimer = new DownloadTimer( getActivity() );\n                    Log.i( TAG, "*** Starting download timer... ***" );\n                    downloadTimer.start( DOWNLOAD_TIMEOUT ); // milliseconds before "alarm" goes off\n\n                } else {\n                    // Log.i(TAG, "*** mProgressDialog is either not null or is showing! ***");\n                }\n\n\n                if( mProgressDialog != null ) {\n\n                    /*\n                     * restart download timer...\n                     */\n                    if( !downloadTimer.isCancelled() ) {\n                        downloadTimer.restart();\n                    }\n\n                    if( numberOfFilesToDownload != 0 ) {\n                        int progressValue = ( int )( 100 * numberOfdownloadedFiles / numberOfFilesToDownload );\n                        mProgressDialog.setProgress( progressValue );\n                    }\n                }\n            }\n\n            /* Sitemap JSON file */\n            if( file.sourceUri.equals( SITEMAP ) ) {\n\n                if( downloadTemplateJSON ) {\n                    downloadTemplateJSONGotSiteMap = true;\n                }\n\n                try {\n                    JSONObject map = new JSONObject( file.getContents() );\n                    JSONArray pages = map.getJSONArray( "map" );\n\n                    int maxProgress = pages.length();\n                    mProgressDialog.setMax( maxProgress - 2 ); // this is just a placeholder\n\n                    // Start downloading\n                    new AsyncTask< Object, Integer, Void >() {\n                        @Override\n                        protected Void doInBackground( Object... params ) {\n                            JSONArray pages = ( JSONArray )params[ 0 ];\n                            ArrayList< String > downloadPages = new ArrayList< String >();\n                            try {\n                                Settings settings = Settings.getInstance(); // changed to Singleton march 23 -EG\n                                for( int i = 0; i < pages.length(); i++ ) {\n                                    String url;\n                                    if( settings.getBaseUrl() != null && !settings.getBaseUrl().isEmpty() )\n                                        url = settings.getBaseUrl() + settings.getMcbaDir();\n                                    else\n                                        url = settings.getPushUrl();\n\n                                    // take http out\n                                    url = url.replace( "https", "http" );\n\n                                    String page = url + getString( R.string.download_dir ) + pages.getString( i );\n                                    // Log.i(TAG, "*** com.aw page set to: " + url + ". ***");\n\n                                    // Download the file if it doesn\'t exist yet\n                                    String relPath = pages.getString( i );\n                                    //Log.d(TAG, "Considering: "+relPath);\n                                    if( relPath.contains( "backup" ) ) continue; // Do not download!\n                                    if( relPath.contains( "index.php" ) ) {\n                                        relPath = relPath.replace( ".php", ".html" );\n                                    }\n\n                                    if ( relPath.contains( "app_config.json" ) ) {\n                                        downloadPages.add( page );\n                                        continue;\n                                    }\n\n                                    File checkFile = new File( mUpdateManager.getDownloadRoot(), relPath );\n                                    if( checkFile.exists() && !( downloadTemplateJSON && relPath.contains( ".json" ) ) ) {\n                                        // Log.i(TAG, "*** File exists. continuing... ***");\n                                        continue; // Do not download!\n                                    }\n\n                                    if( page.contains( "index.php" ) ) {\n                                        page += "?mobile=true";\n                                    }\n\n                                    downloadPages.add( page );\n                                }\n\n                                /*\n                                 * got number of pages to download, now\n                                 * set the private variable for the progress\n                                 * calculation\n                                 */\n                                // this.onProgressUpdate(downloadPages.size());\n                                numberOfFilesToDownload = downloadPages.size();\n\n                                for( String dpage : downloadPages ) {\n                                    mUpdateManager.download( dpage ); // enqueue file\n                                }\n                            } catch ( JSONException e ) {\n                                e.printStackTrace();\n                            } catch (IOException e) {\n                                throw new RuntimeException(e);\n                            }\n                            return null;\n                        }\n                    }.execute( pages );\n\n                } catch ( JSONException e ) {\n                    Log.i( TAG, "Sitemap invalid JSON. Website may not exist, or no Internet connection:" + file.sourceUri );\n                    Log.i( TAG, "onDownloadFinished: " + file.getContents() );\n                    if( mWebView.doesIndexExist() ) {\n                        Log.i( TAG, "No files exist" );\n                    }\n                    e.printStackTrace();\n                }\n            }\n\n            if( file.sourceUri.equals( CONFIGJSON ) ) {\n                Log.i( TAG, "*** onDownloadFinished: CONFIGMAP HAS DOWNLOADED ***" );\n\n                Settings settings = Settings.getInstance();\n\n                try {\n                    String source = file.getContents().replace( "var config_data = ", "" );\n                    // strip the last character from the source string if it is not a closing curly brace\n                    if ( !source.substring( source.length() - 1 ).equals( "}" ) ) {\n                        source = source.substring( 0, source.length() - 1 );\n                    }\n\n                    JSONObject obj = new JSONObject( source );\n\n                    JSONObject jObj = obj.getJSONObject( "options" );\n                    String color = jObj.getString( "base_color" );\n                    obj = new JSONObject( color );\n\n                    settings = Settings.getInstance();\n                    settings.setBase_color( obj.getString( "value" ) );\n                    color = jObj.getString( "background_color" );\n                    obj = new JSONObject( color );\n                    settings.setBackground_color( obj.getString( "value" ) );\n                    color = jObj.getString( "page_color" );\n                    obj = new JSONObject( color );\n                    settings.setPage_color( obj.getString( "value" ) );\n                    color = jObj.getString( "menu_text" );\n                    obj = new JSONObject( color );\n                    settings.setText_color( obj.getString( "value" ) );\n\n                } catch ( JSONException e ) {\n                    e.printStackTrace();\n                } catch ( StringIndexOutOfBoundsException sioobe ) {\n                    sioobe.printStackTrace();\n                } // </ try>\n            } // </ if(file.sourceUri.equals(CONFIGJSON)) { >\n        } // </ public void onDownloadFinished(DownloadFile file)>\n\n        @SuppressLint("LogNotTimber")\n        @Override\n        public void onDownloadFailed( DownloadFile file ) {\n            Log.i( TAG, "Download " + file.localUri + " failed: " + file.error );\n\n            if( mUpdateManager.getPendingDownloadCount() <= 0 ) {\n                if( downloadTemplateJSON && downloadTemplateJSONGotSiteMap ) {\n                    downloadTemplateJSON = false;\n                    downloadTemplateJSONGotSiteMap = false;\n                }\n                mWebView.refresh();\n            }\n        }\n    };\n\n    public void promoblast( String message ) {\n        if( mWebView != null ) {\n            mWebView.sendPromoblast( message );\n        }\n    }\n\n    public void update( ) throws IOException {\n        downloadTemplateJSON = true;\n        mUpdateManager.download( CONFIGJSON );\n        mUpdateManager.download( SITEMAP );\n    }\n\n    private void deleteRecursive( File fileOrDirectory ) {\n        if( fileOrDirectory.isDirectory() )\n            for( File child : fileOrDirectory.listFiles() ) {\n                deleteRecursive( child );\n            }\n        fileOrDirectory.delete();\n    }\n\n    @Override\n    public void onSaveInstanceState( Bundle saveState ) {\n        super.onSaveInstanceState( saveState );\n    }\n\n    @Override\n    public void onDestroyView( ) {\n        mUpdateManager.close();\n        if( mProgressDialog != null && mProgressDialog.isShowing() ) {\n            mProgressDialog.dismiss();\n        }\n        super.onDestroyView();\n    }\n\n}\nDownloadFile.java:\npackage com.awm.mcba.base.initial_download_operations;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\nimport android.app.DownloadManager;\nimport android.content.Context;\nimport android.database.Cursor;\n\nclass DownloadFile {\n\n\tint\t\tstatus = -1;\n\tString  error = "Success";\n\tString \tsourceUri = null;\n\tString \tlocalUri = null;\n\n\tDownloadFile(Context context, Cursor c){\n\t\tif(!c.moveToFirst()) return;\t\n\t\t\n        this.status = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS));\n\t\tint reason = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_REASON));\n\t\tthis.sourceUri = c.getString(c.getColumnIndex(DownloadManager.COLUMN_URI));\n\t\tthis.localUri = c.getString(c.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));\n\t\tString relativePath = c.getString(c.getColumnIndex(DownloadManager.COLUMN_DESCRIPTION));\n\t\tthis.localUri = context.getExternalFilesDir(null).getAbsolutePath() + "/" + relativePath;\n        if (status == DownloadManager.STATUS_FAILED){\n\t\t\tswitch (reason) {\n\t\t\tcase DownloadManager.ERROR_CANNOT_RESUME:\n\t\t\t\terror = "ERROR_CANNOT_RESUME";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_DEVICE_NOT_FOUND:\n\t\t\t\terror = "ERROR_DEVICE_NOT_FOUND";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n\t\t\t\terror = "ERROR_FILE_ALREADY_EXISTS";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_FILE_ERROR:\n\t\t\t\terror = "ERROR_FILE_ERROR";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_HTTP_DATA_ERROR:\n\t\t\t\terror = "ERROR_HTTP_DATA_ERROR";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_INSUFFICIENT_SPACE:\n\t\t\t\terror = "ERROR_INSUFFICIENT_SPACE";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_TOO_MANY_REDIRECTS:\n\t\t\t\terror = "ERROR_TOO_MANY_REDIRECTS";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_UNHANDLED_HTTP_CODE:\n\t\t\t\terror = "ERROR_UNHANDLED_HTTP_CODE";\n\t\t\t\tbreak;\n\t\t\tcase DownloadManager.ERROR_UNKNOWN:\n\t\t\t\terror = "ERROR_UNKNOWN";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = "UNKNOWN";\n\t\t\t}\n        }\n\t\tc.close();\n\t}\n\t\n\tpublic String getContents(){\n\t\tif(localUri == null) return null;\n\t\tStringBuilder fileData = new StringBuilder();\n\t    try {\n\t\t\t/* Read the file into a String */\n\t\t    BufferedReader br = new BufferedReader(new FileReader(new File(localUri)));\n\t\t    String line;\n\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\tfileData.append(line);\n\t\t\t\t//fileData.append(\'\\n\');\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t    return fileData.toString();\n\t}\n}\n\nMcbaUpdateManager.java:\npackage com.awm.mcba.base.initial_download_operations;\n\nimport static android.content.Context.RECEIVER_EXPORTED;\nimport static androidx.core.content.ContextCompat.getSystemService;\n\nimport android.app.DownloadManager;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.util.Log;\nimport com.awm.mcba.base.messages.WriteLog;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nclass McbaUpdateManager {\n    private static final String TAG = "McbaUpdateManager";\n    private final Context context                  /* = not set */;\n    private final ArrayList< Long > mDownloadIds = new ArrayList<>();\n    private final DownloadManager mDownloadManager         /* = not set */;\n    private DownloadFinishedListener mDownloadFinishedListener = null;\n    private File mDownloadRoot = null;\n    public static boolean reload = false;\n    public WriteLog logger = new WriteLog( "https://floridascarwash.com/catchLog.php" );\n\n\n    interface DownloadFinishedListener {\n        void onDownloadFinished( DownloadFile file );\n        void onDownloadFailed( DownloadFile file ); }\n\n    McbaUpdateManager( Context context ) {\n        File filesDir = context.getExternalFilesDir( null );\n        if( filesDir != null ) {\n            try {\n                filesDir.createNewFile();\n            } catch ( IOException e ) {\n                e.printStackTrace();\n            }\n        }\n\n        this.mDownloadRoot = new File( filesDir.getAbsolutePath() + "/www/" );\n        this.context = context;\n        mDownloadManager = ( DownloadManager )context.getSystemService( context.DOWNLOAD_SERVICE );\n        context.registerReceiver( downloadReceiver, new IntentFilter( DownloadManager.ACTION_DOWNLOAD_COMPLETE ), RECEIVER_EXPORTED );\n        //context.registerReceiver(broadcastReceiver, intentFilter, RECEIVER_EXPORTED);\n    }\n\n    long download( String source ) throws IOException { /** Download a file via HTTP. */\n        String destination = source.substring( source.indexOf( "www/" ) );\n\n        \n        if( destination.contains( "index.php" ) ) {// Fix php file type.  remove query strings\n            destination = destination.replace( ".php", ".html" );\n            destination = destination.substring( 0, destination.lastIndexOf( "?" ) ); }\n        if( destination.contains( "sitemap.php" ) ) {\n            destination = destination.replace( ".php", ".json" ); }\n\n        /* Delete file so it can be overwritten */\n        File dest = new File( this.mDownloadRoot, destination.substring( destination.indexOf( "www/" ) + 4 ) );\n        dest.mkdirs();\n        if( dest.exists()) { dest.delete(); }\n        source = source.replace( "http://", "https://" ); // replace http with https\n        logger.log( TAG, "*** before parsing source " + source + "*** ..." );\n        DownloadManager.Request request = new DownloadManager.Request( Uri.parse( source ) );\n        request.setTitle( "Updating" );\n        request.setDescription( destination );\n        request.setVisibleInDownloadsUi( false );\n        request.setDestinationInExternalFilesDir( context, null, destination );\n\n        /*\n         * is this where the download is fired?\n         */\n        logger.log( TAG, "*** MCBAUpdateManager: enqueuing source: " + source + " ***" );\n        long addedRequest = mDownloadManager.enqueue( request );\n\n        logger.log( TAG, "*** MCBAUpdateManager: adding " + addedRequest + " to mDownloadIds ***" );\n        mDownloadIds.add( addedRequest );\n\n        //return addedRequest; // replace on 0329 -EG  maybe below?\n        return mDownloadIds.get( mDownloadIds.size() - 1 );\n    }\n\n    int getPendingDownloadCount( ) { return this.mDownloadIds.size(); }\n\n    void setDownloadFinishedListener( DownloadFinishedListener listener ) {\n        this.mDownloadFinishedListener = listener;\n    }\n\n    File getDownloadRoot() { return this.mDownloadRoot; }\n\n    private final BroadcastReceiver downloadReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive( Context context, Intent intent ) {\n\n            if( !intent.getAction().equals( DownloadManager.ACTION_DOWNLOAD_COMPLETE ) ) {\n                logger.log( TAG, "***  MCBAUpdateManager: Action " + intent.getAction() + " ***" );\n\n                logger.log( TAG, "***  MCBAUpdateManager: an onReceive was triggered, but the intent action is not download complete.  returning... ***" );\n                return;  // not a completed download? ...return.  // added april 4, 2018 -EG\n            }\n            long downloadId = intent.getLongExtra( DownloadManager.EXTRA_DOWNLOAD_ID, 0L );\n            if( !mDownloadIds.contains( downloadId ) ) {\n                logger.log( TAG, "***  Ignoring download id " + downloadId + "... ***" );\n                return;\n            }\n\n            DownloadManager downloadManager = (DownloadManager) getSystemService( context, DownloadManager.class );\n            DownloadManager.Query query = new DownloadManager.Query();\n            query.setFilterById(downloadId); // replace \'downloadId\' with the ID of your download\n            Cursor cursor = downloadManager.query(query);\n            if (cursor.moveToFirst()) {\n                int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_REASON);\n                int reason = cursor.getInt(columnIndex);\n                // print reason\n                logger.log(TAG, "***  MCBAUpdateManager: reason: " + reason + " ***");\n                System.out.println("***  MCBAUpdateManager: reason: " + reason + " ***");\n            }\n\n            DownloadFile file = new DownloadFile( context.getApplicationContext(), mDownloadManager.query( query ) );\n            // print file status\n            logger.log( TAG, "***  MCBAUpdateManager: file status: " + file.status + " ***" );\n            System.out.println( "***  MCBAUpdateManager: file status: " + file.status + " ***");\n            mDownloadIds.remove( downloadId );\n            logger.log(TAG, "***  MCBAUpdateManager: removing file: " + file.toString() + " from our array... ***");\n            logger.log(TAG, "***  MCBAUpdateManager: mDownloadIds size: " + mDownloadIds.size() + " ***");\n\n            if( file.status != DownloadManager.STATUS_SUCCESSFUL ) {\n                logger.log( TAG, "*** Download manager status is unsuccessful! ***" );\n                DownloadStatus( downloadId );\n                mDownloadFinishedListener.onDownloadFailed( file );\n                return; }\n            if( mDownloadFinishedListener != null ) {\n                logger.log( TAG, "***  mDownloadFinishedListener is NOT null ***" );\n                mDownloadFinishedListener.onDownloadFinished( file ); }\n        } // </ onReceive()>\n    }; // </ downloadReceiver definition>\n\n    void close( ) {\n        context.unregisterReceiver( downloadReceiver );\n    }\n\n    private void DownloadStatus( long DownloadId ) {\n        DownloadManager.Query q = new DownloadManager.Query();\n        q.setFilterById( DownloadId );\n        Cursor cursor = mDownloadManager.query( q );\n        if( cursor == null || cursor.getCount() == 0 ) {\n            // Toast.makeText(context, "junk cursor", Toast.LENGTH_LONG).show();\n            logger.log( TAG, "junk cursor" );\n            return; }\n        cursor.moveToFirst();\n        int columnIndex = cursor.getColumnIndex( DownloadManager.COLUMN_STATUS );\n        int status = cursor.getInt( columnIndex );\n        int columnReason = cursor.getColumnIndex( DownloadManager.COLUMN_REASON );\n        int reason = cursor.getInt( columnReason );\n        int filenameIndex = cursor.getColumnIndex( DownloadManager.COLUMN_LOCAL_URI );\n        String filename = cursor.getString( filenameIndex );\n\n        String statusText = "";\n        String reasonText = "";\n\n        switch ( status ) {\n            case DownloadManager.STATUS_FAILED:\n                statusText = "STATUS_FAILED";\n                switch ( reason ) {\n                    case DownloadManager.ERROR_CANNOT_RESUME:\n                        reasonText = "ERROR_CANNOT_RESUME";\n                        break;\n                    case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                        reasonText = "ERROR_DEVICE_NOT_FOUND";\n                        break;\n                    case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                        reasonText = "ERROR_FILE_ALREADY_EXISTS";\n                        break;\n                    case DownloadManager.ERROR_FILE_ERROR:\n                        reasonText = "ERROR_FILE_ERROR";\n                        break;\n                    case DownloadManager.ERROR_HTTP_DATA_ERROR:\n                        reasonText = "ERROR_HTTP_DATA_ERROR";\n                        break;\n                    case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                        reasonText = "ERROR_INSUFFICIENT_SPACE";\n                        break;\n                    case DownloadManager.ERROR_TOO_MANY_REDIRECTS:\n                        reasonText = "ERROR_TOO_MANY_REDIRECTS";\n                        break;\n                    case DownloadManager.ERROR_UNHANDLED_HTTP_CODE:\n                        reasonText = "ERROR_UNHANDLED_HTTP_CODE";\n                        break;\n                    case DownloadManager.ERROR_UNKNOWN:\n                        reasonText = "ERROR_UNKNOWN";\n                        break;\n                }\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                statusText = "STATUS_PAUSED";\n                switch ( reason ) {\n                    case DownloadManager.PAUSED_QUEUED_FOR_WIFI:\n                        reasonText = "PAUSED_QUEUED_FOR_WIFI";\n                        break;\n                    case DownloadManager.PAUSED_UNKNOWN:\n                        reasonText = "PAUSED_UNKNOWN";\n                        break;\n                    case DownloadManager.PAUSED_WAITING_FOR_NETWORK:\n                        reasonText = "PAUSED_WAITING_FOR_NETWORK";\n                        break;\n                    case DownloadManager.PAUSED_WAITING_TO_RETRY:\n                        reasonText = "PAUSED_WAITING_TO_RETRY";\n                        break;\n                }\n                break;\n            case DownloadManager.STATUS_PENDING:\n                statusText = "STATUS_PENDING";\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                statusText = "STATUS_RUNNING";\n                break;\n            case DownloadManager.STATUS_SUCCESSFUL:\n                statusText = "STATUS_SUCCESSFUL";\n                reasonText = "Filename:\\n" + filename;\n                break;\n        }\n        logger.log( TAG, "File Download Status:" + "\\n" + statusText + "\\n" + reasonText );\n        final Handler handler = new Handler();\n        handler.postDelayed( new Runnable() {\n            @Override\n            public void run( ) {\n            }\n        }, 3000 ); }}\n\n\n\nDescribe the program in markdown using specific language that will help another AI program reconstruct the given program in as high fidelity as possible.